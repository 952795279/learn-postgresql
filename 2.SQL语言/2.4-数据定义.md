# 数据定义

## 1.表格基础  
创建表
```
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
```

删除表
```
DROP TABLE my_first_table;
```

## 2.默认值  
默认值在新行创建时自动填充值（如果该字段没插入值）  
如果没有声明默认值，默认值为空  
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric DEFAULT 9.99
);
```
默认值可以为表达式。如，timestamp的当前时间值CURRENT_TIMESTAMP  
序列号生成，如例：
```
CREATE TABLE products (
    product_no integer DEFAULT nextval('products_product_no_seq'),
    ...
)
```

## 3.生成的列  
根据其它列计算得出  
类型分“存储列”和“虚拟列”, 存储列在写入（插入或更新）时进行计算，并像普通列一样占用存储空间。虚拟生成列不占用存储空间，在读取时进行计算
```
-- 存储列
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED
)
```
生成列和涉及生成列的表的定义有几个限制：  
- 生成表达式只能使用不可变函数，不能使用子查询或以任何方式引用当前行以外的任何内容。
  
- 生成表达式不能引用另一个生成的列。
  
- 生成表达式不能引用系统列，但除外tableoid。
  
- 生成的列不能具有列默认值或标识定义。
  
- 生成的列不能成为分区键的一部分。
  
- 外部表可以包含生成列。详情请参阅CREATE FOREIGN TABLE 。
  
- 对于继承：
  + 如果父列是生成列，则子列也必须是使用相同表达式的生成列。在子列的定义中，省略该GENERATED子句，因为它将从父列复制。
  
  + 在多重继承的情况下，如果一个父列是生成列，则所有父列都必须是生成列且具有相同的表达式。
  
  + 如果父列不是生成列，则子列可以被定义为生成列，也可以不定义为生成列。
    
使用生成的列时还需考虑其他事项。
- 生成列的访问权限与其底层基列的访问权限是分开的。因此，可以进行如下安排：特定角色只能从生成列读取数据，但不能从底层基列读取数据。

- 从概念上讲，生成列在BEFORE触发器运行后会更新。因此，BEFORE触发器中对基列的更改将反映在生成列中。但反过来，不允许在BEFORE触发器中访问生成列。

- 逻辑复制时会跳过生成的列，并且不能在CREATE PUBLICATION列列表中指定。
